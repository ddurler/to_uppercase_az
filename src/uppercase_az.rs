/// DO NOT MODIFY
/// This file is automatically generated by command 'cargo run <filename>
///
use lazy_static::lazy_static;

use std::collections::HashMap;
use std::ops::Index;

use crate::letter::Letter;
use crate::property::Property;
use crate::uppercase::{Uppercase, NOT_AN_UPPERCASE};

// Construct a Hashmap for uppercase AZ equivalent
include!("hash_uppercase_az.rs");

/// All Uppercase AZ equivalent
#[derive(Debug, Clone)]
pub struct UppercaseAZ<'a>(&'a HashMap<u32, Uppercase>);

impl Default for UppercaseAZ<'_> {
    fn default() -> Self {
        UppercaseAZ(&UPPERCASE_AZ)
    }
}

impl Index<char> for UppercaseAZ<'_> {
    type Output = Uppercase;

    fn index(&self, index: char) -> &Self::Output {
        self.get_ref(index)
    }
}

impl UppercaseAZ<'_> {
    #[must_use]
    pub fn get(&self, c: char) -> Option<Uppercase> {
        let code_point = c as u32;
        self.0.get(&code_point).copied()
    }

    #[must_use]
    pub fn get_ref(&self, c: char) -> &Uppercase {
        let code_point = c as u32;
        self.0
            .get(&code_point)
            .map_or(&NOT_AN_UPPERCASE, |uppercase| uppercase)
    }

    #[must_use]
    pub fn option_string(&self, c: char) -> Option<String> {
        let code_point = c as u32;
        self.0
            .get(&code_point)
            .map(|uppercase| uppercase.letter.to_string())
    }

    #[must_use]
    pub fn to_string(&self, txt: &str) -> String {
        let mut result = String::new();
        for c in txt.chars() {
            result.push_str(&self.option_string(c).unwrap_or_else(|| c.to_string()));
        }
        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_uppercase_az_get() {
        let uppercase_az = UppercaseAZ::default();
        assert_eq!(
            uppercase_az.get('A'),
            Some(Uppercase {
                letter: Letter::Letter('A'),
                property: Property::Capital
            })
        );
        assert_eq!(
            uppercase_az.get('a'),
            Some(Uppercase {
                letter: Letter::Letter('A'),
                property: Property::Small
            })
        );
        assert_eq!(
            uppercase_az.get('Â'),
            Some(Uppercase {
                letter: Letter::Letter('A'),
                property: Property::CapitalWithDecoration
            })
        );
        assert_eq!(
            uppercase_az.get('à'),
            Some(Uppercase {
                letter: Letter::Letter('A'),
                property: Property::SmallWithDecoration
            })
        );
        assert_eq!(
            uppercase_az.get('Æ'),
            Some(Uppercase {
                letter: Letter::Letters('A', 'E'),
                property: Property::Capital
            })
        );
        assert_eq!(
            uppercase_az.get('Æ'),
            Some(Uppercase {
                letter: Letter::Letters('A', 'E'),
                property: Property::Capital
            })
        );
        assert_eq!(
            uppercase_az.get('Œ'),
            Some(Uppercase {
                letter: Letter::Letters('O', 'E'),
                property: Property::Capital
            })
        );
        assert_eq!(
            uppercase_az.get('œ'),
            Some(Uppercase {
                letter: Letter::Letters('O', 'E'),
                property: Property::Small
            })
        );
    }

    #[test]
    fn test_uppercase_az_get_nonexistent_letter() {
        let uppercase_az = UppercaseAZ::default();
        assert_eq!(uppercase_az.get('2'), None);
    }

    #[test]
    fn test_uppercase_az_get_string() {
        let uppercase_az = UppercaseAZ::default();
        assert_eq!(uppercase_az.option_string('A'), Some("A".to_string()));
        assert_eq!(uppercase_az.option_string('a'), Some("A".to_string()));
        assert_eq!(uppercase_az.option_string('Æ'), Some("AE".to_string()));
        assert_eq!(uppercase_az.option_string('œ'), Some("OE".to_string()));
    }

    #[test]
    fn test_uppercase_az_index() {
        let uppercase_az = UppercaseAZ::default();
        assert_eq!(
            uppercase_az['A'],
            Uppercase {
                letter: Letter::Letter('A'),
                property: Property::Capital
            }
        );
        assert_eq!(
            uppercase_az['a'],
            Uppercase {
                letter: Letter::Letter('A'),
                property: Property::Small
            }
        );
        assert_eq!(
            uppercase_az['Æ'],
            Uppercase {
                letter: Letter::Letters('A', 'E'),
                property: Property::Capital
            }
        );
    }

    #[test]
    fn test_uppercase_az_to_string() {
        let uppercase_az = UppercaseAZ::default();

        assert_eq!(uppercase_az.to_string("A"), "A");
        assert_eq!(uppercase_az.to_string("ab"), "AB");
        assert_eq!(uppercase_az.to_string("2"), "2");
        assert_eq!(uppercase_az.to_string("à l'œil"), "A L'OEIL");
    }
}
