/// DO NOT MODIFY
/// This file is automatically generated by command 'cargo run <filename>
use lazy_static::lazy_static;

use std::collections::HashMap;
use std::fmt::Display;
use std::ops::Index;

/// Enumeration for uppercase AZ equivalent
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Letter {
    /// Single uppercase letter equivalent
    Letter(char),

    /// Double uppercase letter equivalent
    Letters(char, char),
}

impl Display for Letter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Letter(c) => write!(f, "{c}"),
            Self::Letters(c1, c2) => write!(f, "{c1}{c2}"),
        }
    }
}

/// Enumeration for uppercase AZ decoration
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Property {
    NotAnUppercase,
    Capital,
    Small,
    SmallAndCapital,
    CapitalWithDecoration,
    SmallWithDecoration,
    SmallAndCapitalWithDecoration,
}

impl Property {
    #[must_use]
    pub const fn is_capital(self) -> bool {
        matches!(
            self,
            Self::Small
                | Self::SmallAndCapital
                | Self::SmallWithDecoration
                | Self::SmallAndCapitalWithDecoration
        )
    }

    #[must_use]
    pub const fn is_small(self) -> bool {
        matches!(
            self,
            Self::Small
                | Self::SmallAndCapital
                | Self::SmallWithDecoration
                | Self::SmallAndCapitalWithDecoration
        )
    }

    #[must_use]
    pub const fn is_decoration(self) -> bool {
        matches!(
            self,
            Self::CapitalWithDecoration
                | Self::SmallWithDecoration
                | Self::SmallAndCapitalWithDecoration
        )
    }
}

/// Unicode code point properties
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Uppercase {
    // Uppercase letter(s) equivalent
    pub letter: Letter,

    // Uppercase letter(s) properties
    pub property: Property,
}

impl Display for Uppercase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.letter)
    }
}

// Construct a Hashmap for uppercase AZ equivalent
#[rustfmt::skip]
lazy_static! {
    static ref UPPERCASE_AZ: HashMap<u32, Uppercase> = {
        let mut m = HashMap::new();
        m.insert(65, Uppercase {letter: Letter::Letter('A'), property: Property::Capital});
        m
    };
}

/// Default uppercase AZ for not equivalent
pub const NOT_A_UPPERCASE: Uppercase = Uppercase {
    letter: Letter::Letter('?'),
    property: Property::NotAnUppercase,
};

/// All Uppercase AZ equivalent
#[derive(Debug, Clone)]
pub struct UppercaseAZ<'a>(&'a HashMap<u32, Uppercase>);

impl Default for UppercaseAZ<'_> {
    fn default() -> Self {
        UppercaseAZ(&UPPERCASE_AZ)
    }
}

impl Index<char> for UppercaseAZ<'_> {
    type Output = Uppercase;

    fn index(&self, index: char) -> &Self::Output {
        self.get_ref(index)
    }
}

impl UppercaseAZ<'_> {
    #[must_use]
    pub fn get(&self, c: char) -> Option<Uppercase> {
        let code_point = c as u32;
        self.0.get(&code_point).copied()
    }

    #[must_use]
    pub fn get_ref(&self, c: char) -> &Uppercase {
        let code_point = c as u32;
        self.0
            .get(&code_point)
            .map_or(&NOT_A_UPPERCASE, |uppercase| uppercase)
    }

    #[must_use]
    pub fn get_string(&self, c: char) -> Option<String> {
        let code_point = c as u32;
        self.0
            .get(&code_point)
            .map(|uppercase| uppercase.letter.to_string())
    }

    #[must_use]
    pub fn to_string(&self, c: char) -> String {
        self.get_string(c).map_or_else(|| c.to_string(), |s| s)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_uppercase_az_get() {
        let uppercase_az = UppercaseAZ::default();
        assert_eq!(
            uppercase_az.get('A'),
            Some(Uppercase {
                letter: Letter::Letter('A'),
                property: Property::Capital
            })
        );
        assert_eq!(uppercase_az.get_string('A'), Some("A".to_string()));
        assert_eq!(uppercase_az.to_string('A'), "A".to_string());
    }

    #[test]
    fn test_uppercase_az_index() {
        let uppercase_az = UppercaseAZ::default();
        assert_eq!(
            uppercase_az['A'],
            Uppercase {
                letter: Letter::Letter('A'),
                property: Property::Capital
            }
        );
    }

    #[test]
    fn test_uppercase_az_get_nonexistent_letter() {
        let uppercase_az = UppercaseAZ::default();
        assert_eq!(uppercase_az.get('2'), None);
        assert_eq!(uppercase_az.to_string('2'), "2");
    }
}
